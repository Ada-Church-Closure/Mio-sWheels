# 手写简单线程池

## 线程池基本参数?

核心 最大 阻塞队列模型 拒绝策略问题 超时.

## 你怎么理解拒绝策略?

本质上我们只希望core thread来执行任务.

## SHUTDOWN and SHUTDOWNNOW?

给所有正在运行的线程发interrupt信号或者是直接结束.

对于 Java 后端实习面试（尤其是大厂），**线程池（ThreadPoolExecutor）** 是 **JUC（Java.util.concurrent）** 包中考察频率最高、深度最可控的知识点，没有之一。

### 第一关：死记硬背（必须滚瓜烂熟）

这部分是门槛，答错了直接扣大分。

#### 1. 核心构造参数（7个）

不要只背名字，要能说出它们的作用：

1. **`corePoolSize` (核心线程数)**：常驻线程数，即使空闲也不会被回收（除非设置了 `allowCoreThreadTimeOut`）。
2. **`maximumPoolSize` (最大线程数)**：线程池能容纳的最大线程数量。
3. **`keepAliveTime` (存活时间)**：当线程数 > corePoolSize 时，多余的空闲线程在终止前等待新任务的最长时间。
4. **`unit` (时间单位)**：**keepAliveTime** 的单位。
5. **`workQueue` (任务队列)**：用来储存等待执行任务的阻塞队列。
6. **`threadFactory` (线程工厂)**：用来创建新线程。**注意点：** 建议自定义，可以给线程**设置有意义的名字**，方便排查问题。
7. **`handler` (拒绝策略)**：当队列满且线程达到最大值时，如何拒绝新任务。

#### 2. 拒绝策略（4种原生）

1. **`AbortPolicy` (默认)**：直接抛出 `RejectedExecutionException` 异常。
2. **`CallerRunsPolicy`**：由调用线程（提交任务的线程）处理该任务。**（重点：这会降低提交速度，起到负反馈作用）**。
3. **`DiscardPolicy`**：直接丢弃任务，不抛出异常。
4. **`DiscardOldestPolicy`**：丢弃队列中最老的任务，然后重新尝试提交当前任务。

------

### 第二关：核心原理（逻辑要清晰）

这部分考察你的逻辑思维，通常面试官会问：“**一个任务提交到线程池，会发生什么？**”

你需要画出（或口述）这个流程图：

1. **判断核心线程：** 当前线程数 < `corePoolSize`？
   - 是：创建新线程执行任务。
   - 否：下一步。
2. **判断队列：** 队列没满？
   - 是：放入队列等待。
   - 否：下一步。
3. **判断最大线程：** 当前线程数 < `maximumPoolSize`？
   - 是：创建非核心线程执行任务。
   - 否：下一步。
4. **拒绝：** 执行拒绝策略。

**⚠️ 坑点注意：** 很多初学者会以为“核心满了先开非核心，最后才进队列”。**错！是先进队列，队列满了才开非核心。**

------

### 第三关：工程实践（避坑指南）

#### 1. 为什么阿里巴巴禁止使用 `Executors` 创建线程池？

- **问题：** `Executors.newFixedThreadPool()` 和 `newSingleThreadExecutor()`。
- **原因：** 它们默认使用了 `LinkedBlockingQueue`，这是一个**无界队列**（容量为 `Integer.MAX_VALUE`）。
- **后果：** 任务堆积过多会导致 **OOM (Out Of Memory)**。
- **正确姿势：** 手动 `new ThreadPoolExecutor()`，明确指定队列大小。

#### 2. 线程数怎么设置合理？（参数调优）

这是一个开放性问题，标准回答是分场景：

- **CPU 密集型任务（加密、计算、排序）：**
  - 配置：`CPU 核数 + 1`。
  - 原因：线程主要在利用 CPU，减少线程切换开销。`+1` 是为了防止缺页中断等情况导致 CPU 空闲。
- **IO 密集型任务（读写数据库、文件、网络请求）：**
  - 配置：`CPU 核数 * 2` （或者 `CPU 核数 / (1 - 阻塞系数)`）。
  - 原因：线程大部分时间在等待 IO，CPU 空闲，所以可以多开点线程抢占 CPU。

#### 3. `shutdown()` 和 `shutdownNow()` 的区别？

- **`shutdown()`**：温和。不再接收新任务，但会把队列里已有的任务执行完。
- **`shutdownNow()`**：粗暴。不再接收新任务，尝试中断正在执行的任务，并返回队列中未执行的任务列表。

------

### 第四关：源码深挖

#### 1. 线程池状态怎么存的？（ctl 变量）

- **源码：** `private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));`
- **原理：** 用一个 `int` (32位) 同时存两个值。
  - **高 3 位：** 线程池状态（RUNNING, SHUTDOWN, STOP, TIDYING, TERMINATED）。
  - **低 29 位：** 线程数量。
- **为什么这么做？** 为了省空间，且通过一次 CAS 操作就能同时更新状态和数量，保证并发安全。

#### 2. Worker 是什么？

- 线程池里的线程被封装成了 `Worker` 对象。
- `Worker` 继承了 `AQS`，实现了 `Runnable`。
- 它启动后会通过一个 `while` 循环（`runWorker` 方法），不断从队列里 `getTask()` 获取任务执行。**这也是线程复用的原理。**

#### 3. 线程是如何“保活”和“回收”的？

- **保活：** 核心线程在从队列 `take()` 任务时，如果队列为空，会一直阻塞（`workQueue.take()`）。
- **回收：** 非核心线程（或允许超时的核心线程）使用的是 `workQueue.poll(time, unit)`。如果超时没拿到任务，循环结束，线程销毁。

------

### 面试模拟题

1. **面试官：** 讲一下线程池的执行流程？
   - *（用第二关的逻辑回答）*
2. **面试官：** 如果队列满了，我设置的最大线程数是无穷大，会发生什么？
   - *（答：虽然不会拒绝，但机器可能会卡死或 OOM，因为创建了无限多的线程）*
3. **面试官：** 如果我把 `corePoolSize` 设为 0 会怎样？
   - *（答：任务一提交就会进队列。如果队列还没满，任务就躺在队列里没人理它（除非设置了 prestart）。**更正**：**实际上 JDK 实现中，如果 core=0，入队后会检查 worker 数量，如果为 0 会创建一个非核心线程来拉取任务**。这一细节能答出来很加分）*
4. **面试官：** 你的项目中哪里用到了线程池？参数怎么配的？
   - *（结合 Howaito-Album 的 RocketMQ 消费或者异步下单逻辑。参数可以说：因为是 IO 密集型，我参考公式设为了 2N，配合有界队列 1000，拒绝策略用的 **CallerRuns** 保证不丢数据。）*